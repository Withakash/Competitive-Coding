Competitive Coding â€” Practical Programs & Notes (303105259)

This repository contains all 25 practical programs, notes, and topic-wise implementations for the subject Competitive Coding.
The goal is to build strong fundamentals in data structures, algorithms, and problem-solving techniques used in coding interviews and competitive programming.

ðŸ“Œ Table of Contents

Introduction

Syllabus Focus

Practical Explanations (1â€“25)

Folder Structure

How to Run

Recommended Platforms

Contribute

ðŸ“˜ Introduction

This repository contains simple and clean code implementations for every practical listed in the Competitive Coding syllabus.
Each program is written with clarity so students can easily understand logic, modify code, and practice for exams and interviews.

ðŸŽ¯ Syllabus Focus

This subject helps students build:

Strong problem-solving abilities

Practical coding experience

Understanding of real-world data structure usage

Efficient algorithmic thinking

Confidence for coding rounds & competitive contests

ðŸ§ª Practical Explanations (1â€“25)

Below is a clear and easy explanation of each practical and what youâ€™ll learn from it.

1. MINSTACK Implementation

Design a stack that, apart from regular operations (push, pop), can also return the minimum element in constant time.
Useful for interview questions based on stack optimization.

2. Expression Evaluation Using Stack

Evaluate postfix or prefix expressions using a stack.
Demonstrates how compilers and calculators handle expressions internally.

3. Next Greater Element (NGE)

For every element in an array, find the next greater element to its right.
A classic stack-based problem widely asked in interviews.

4. Circular Queue (k)

Implement a circular queue supporting enqueue, dequeue, front, and rear operations.
Shows how queues efficiently use memory by wrapping around.

5. Infix to Postfix Conversion (Shunting Yard Algorithm)

Convert an infix expression (like A+B*C) into postfix using a queue and stack.
Develops understanding of operator precedence and parsing.

6. Product of Three Largest Distinct Elements (Priority Queue)

Find the product of the top 3 largest distinct numbers using a max heap.
Trains on heap operations and priority-based selection.

7. Merge Two Sorted Linked Lists

Merge two sorted linked lists into one sorted list.
A fundamental operation in linked list manipulation and used in merge sort.

8. Find Merge Point of Two Linked Lists

Detect the node where two linked lists intersect.
Teaches pointer manipulation and linked list traversal patterns.

9. Swap Nodes Pairwise

Swap nodes of a linked list in pairs (not values).
Improves pointer handling skills.

10. Validate a BST (isValidBST)

Check whether a binary tree follows BST rules.
Important for understanding tree properties and recursion.

11. Build a BST

Construct a Binary Search Tree using insert operations.
Builds foundation for all BST-related problems.

12. Max Depth of Binary Tree

Find the height of a tree using recursion.
Essential for understanding tree structure.

13. Tree Traversals â€” Preorder, Inorder, Postorder

Implement the 3 fundamental traversal methods.
Core building block for all future tree problems.

14. Boundary Traversal of Binary Tree

Print nodes that lie on the boundary (left boundary, leaves, right boundary).
Enhances tree-view understanding.

15. Lowest Common Ancestor (LCA)

Find the common ancestor of two nodes in a BST or Binary Tree.
Highly important interview problem.

16. Mirror Tree Check

Check whether two trees are mirror images of each other.
Builds understanding of symmetric tree logic.

17. Basic Hash Function

Write and test a simple custom hash function.
Introduces hashing concepts used in real-world applications.

18. Hash Table Using Separate Chaining

Implement a full hash table with insertion, deletion, and search.
Teaches collision handling and hash table design.

19. Two Sum Using HashMap

Find indices of two numbers that add up to a target using hashing.
One of the most famous coding interview problems.

20. Trie â€” Insert, Search, Delete

Implement a Trie structure supporting basic operations.
Useful for prefix-based searching and autocomplete logic.

21. Huffman Coding

Implement Huffman coding for data compression.
Demonstrates greedy algorithm and tree-based encoding.

22. Distinct Substrings of a String

Find total number of distinct substrings using Trie or hashing.
Strengthens understanding of string algorithms.

23. Count Words in Trie

Count how many words are stored in a Trie.
Helpful for dictionary and text-based applications.

24. Left View of a Binary Tree

Print the nodes visible when the tree is viewed from the left side.
Enhances tree traversal knowledge.

25. Level Order Traversal

Perform Breadth First Search (BFS) on a tree using a queue.
Foundation for many advanced tree algorithms.
