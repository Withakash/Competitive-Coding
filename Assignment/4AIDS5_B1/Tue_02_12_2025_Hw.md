ğŸ·ï¸ Problem **155**: Min Stack

ğŸ“˜ Description (Paraphrased)

Design a stack that supports the following operations in constant time:

push(x) â€” Add an element x to the top of the stack.

pop() â€” Remove the top element from the stack.

top() â€” Retrieve the element currently at the top.

getMin() â€” Return the smallest value present in the stack.


All four operations must run in O(1) time.

ğŸ”§ Example

Input:
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

Output:
[null,null,null,null,-3,null,0,-2]

ğŸ’¡ Key Insight

To achieve constant-time minimum retrieval, maintain an auxiliary structure (like a second stack) that tracks the minimum value at each level of the main stack.


---

ğŸ·ï¸ Problem **232**: Implement Queue Using Stacks

ğŸ“˜ Description (Paraphrased)

Create a queue using two stacks. The queue must support:

push(x) â€” Insert element x at the back of the queue.

pop() â€” Remove the element at the front.

peek() â€” Return the front element without removing it.

empty() â€” Check whether the queue contains no elements.


You may use only stack operations:

push to stack top

pop from stack top

check if stack is empty

view top element


The goal is to simulate queue behavior (FIFO) using stacks (LIFO).

ğŸ”§ Example

Input:
["MyQueue","push","push","peek","pop","empty"]
[[],[1],[2],[],[],[]]

Output:
[null,null,null,1,1,false]

ğŸ’¡ Key Insight

Use two stacks:

One for enqueue operations

Another for dequeue operations (reverse order)


Transfer elements only when needed to ensure amortized O(1) performance.
